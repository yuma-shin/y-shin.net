---
export interface Props {
	text: string | string[];
	speed?: number;
	deleteSpeed?: number;
	pauseTime?: number;
	class?: string;
}

const {
	text,
	speed = 100,
	deleteSpeed = 50,
	pauseTime = 2000,
	class: className = "",
} = Astro.props;
const textData = Array.isArray(text) ? JSON.stringify(text) : text;
---

<span
  class={`typewriter ${className}`}
  data-text={textData}
  data-speed={speed}
  data-delete-speed={deleteSpeed}
  data-pause-time={pauseTime}
/>

<script type="module">
  // ---- ユーティリティ ----
  const GLOBAL = '__TypewriterGlobal__';
  const ELEM_PROP = '__twInst__';

  // グローバルシングルトン（イベント多重登録防止）
  window[GLOBAL] ||= {
    bound: false,
  };

  class TypewriterEffect {
    /** @type {HTMLElement|null} */ el = null;
    texts = [];
    currentTextIndex = 0;
    speed = 100;
    deleteSpeed = 50;
    pauseTime = 2000;
    currentIndex = 0;
    isDeleting = false;
    timeoutId = null;

    /** @param {HTMLElement} el */
    constructor(el) {
      if (!(el instanceof HTMLElement)) return; // 防御
      this.el = el;

      // 要素がなければ即終了
      if (!this.el) return;

      // dataset は常に防御的に読む
      const d = this.el.dataset ?? {};
      const raw = d.text ?? '';
      try {
        const parsed = JSON.parse(raw);
        this.texts = Array.isArray(parsed) ? parsed : [String(raw)];
      } catch {
        this.texts = [String(raw)];
      }
      this.speed       = Number.parseInt(d.speed ?? '100', 10);
      this.deleteSpeed = Number.parseInt(d.deleteSpeed ?? '50', 10);
      this.pauseTime   = Number.parseInt(d.pauseTime ?? '2000', 10);

      if (this.texts.length > 1 && !this.isTypewriterEnabled(d)) {
        this.showRandomText();
      } else {
        this.start();
      }
    }

    isTypewriterEnabled(d) {
      return d.speed !== undefined || d.deleteSpeed !== undefined || d.pauseTime !== undefined;
    }

    showRandomText() {
      if (!this.el) return;
      const i = Math.floor(Math.random() * this.texts.length);
      this.el.textContent = this.texts[i] ?? '';
    }

    start() {
      if (this.texts.length === 0) return;
      this.loop();
    }

    getCurrentText() {
      return this.texts[this.currentTextIndex] ?? '';
    }

    loop() {
      // 要素がもう存在しない/DOM外なら終了
      if (!this.el || !document.body.contains(this.el)) {
        this.destroy();
        return;
      }

      const current = this.getCurrentText();

      if (this.isDeleting) {
        if (this.currentIndex > 0) {
          this.currentIndex--;
          this.el.textContent = current.slice(0, this.currentIndex);
          this.timeoutId = window.setTimeout(() => this.loop(), this.deleteSpeed);
        } else {
          this.isDeleting = false;
          this.currentTextIndex = (this.currentTextIndex + 1) % this.texts.length;
          this.timeoutId = window.setTimeout(() => this.loop(), this.speed);
        }
      } else {
        if (this.currentIndex < current.length) {
          this.currentIndex++;
          this.el.textContent = current.slice(0, this.currentIndex);
          this.timeoutId = window.setTimeout(() => this.loop(), this.speed);
        } else {
          if (this.texts.length > 1) {
            this.isDeleting = true;
            this.timeoutId = window.setTimeout(() => this.loop(), this.pauseTime);
          }
        }
      }
    }

    destroy() {
      if (this.timeoutId != null) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
      if (this.el) {
        // マーカーを消す
        delete this.el.dataset.twInited;
        delete this.el[ELEM_PROP];
      }
      this.el = null;
    }
  }

  function initAll(root = document) {
    // 差し替え完了後に走るので、最新DOMだけを見る
    const nodes = root.querySelectorAll('.typewriter');
    nodes.forEach((n) => {
      const el = n instanceof HTMLElement ? n : null;
      if (!el) return;
      if (el.dataset.twInited === '1' && el[ELEM_PROP]) return; // 多重防止
      const inst = new TypewriterEffect(el);
      el[ELEM_PROP] = inst;
      el.dataset.twInited = '1';
    });
  }

  function destroyAll(root = document) {
    const nodes = root.querySelectorAll('.typewriter');
    nodes.forEach((n) => {
      const el = n instanceof HTMLElement ? n : null;
      el?.[ELEM_PROP]?.destroy?.();
    });
  }

  // --- 初回: DOM構築完了後に初期化 ---
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => initAll(), { once: true });
  } else {
    // 既にロード済
    initAll();
  }

  // --- Swup連携（多重バインド防止） ---
  if (!window[GLOBAL].bound) {
    // 次の差し替えに入る直前に全破棄（古いタイマー停止）
    document.addEventListener('swup:willReplace', () => {
      destroyAll(document);
    }, { passive: true });

    // 差し替え完了後（DOM確定）に再初期化
    // pageView は最も安定（contentReplaced より後でも来る）
    document.addEventListener('swup:pageView', () => {
      // フレームの描画を待つと更に安全
      requestAnimationFrame(() => initAll(document));
    }, { passive: true });

    window[GLOBAL].bound = true;
  }
</script>

<style>
  .typewriter { position: relative; }
  .typewriter::after {
    content: "|";
    animation: blink 1s infinite;
    margin-left: 2px;
  }
  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%,100% { opacity: 0; }
  }
</style>

