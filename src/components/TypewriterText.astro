---
export interface Props {
	text: string | string[];
	speed?: number;
	deleteSpeed?: number;
	pauseTime?: number;
	class?: string;
}

const {
	text,
	speed = 100,
	deleteSpeed = 50,
	pauseTime = 2000,
	class: className = "",
} = Astro.props;
const textData = Array.isArray(text) ? JSON.stringify(text) : text;
---

<span
  class={`typewriter ${className}`}
  data-text={textData}
  data-speed={speed}
  data-delete-speed={deleteSpeed}
  data-pause-time={pauseTime}
/>

<script type="module">
  class TypewriterEffect {
    /** @type {HTMLElement} */
    element;
    texts = [];
    currentTextIndex = 0;
    speed = 100;
    deleteSpeed = 50;
    pauseTime = 2000;
    currentIndex = 0;
    isDeleting = false;
    timeoutId = null;

    /** @param {HTMLElement} element */
    constructor(element) {
      if (!element) throw new Error('TypewriterEffect: element is null');
      this.element = element;

      const textData = element?.dataset?.text ?? '';
      try {
        const parsed = JSON.parse(textData);
        this.texts = Array.isArray(parsed) ? parsed : [String(textData)];
      } catch {
        this.texts = [String(textData)];
      }

      this.speed = parseInt(element?.dataset?.speed ?? '100', 10);
      this.deleteSpeed = parseInt(element?.dataset?.deleteSpeed ?? '50', 10);
      this.pauseTime = parseInt(element?.dataset?.pauseTime ?? '2000', 10);

      if (this.texts.length > 1 && !this.isTypewriterEnabled()) {
        this.showRandomText();
      } else {
        this.start();
      }
    }

    isTypewriterEnabled() {
      const d = this.element?.dataset ?? {};
      return d.speed !== undefined || d.deleteSpeed !== undefined || d.pauseTime !== undefined;
    }

    showRandomText() {
      const randomIndex = Math.floor(Math.random() * this.texts.length);
      if (this.element) this.element.textContent = this.texts[randomIndex] ?? '';
    }

    start() {
      if (this.texts.length === 0) return;
      this.type();
    }

    getCurrentText() {
      return this.texts[this.currentTextIndex] ?? '';
    }

    type() {
      // 要素が既にDOMから消えていたら終了
      if (!this.element || !document.body.contains(this.element)) {
        this.destroy();
        return;
      }

      const currentText = this.getCurrentText();

      if (this.isDeleting) {
        if (this.currentIndex > 0) {
          this.currentIndex--;
          this.element.textContent = currentText.substring(0, this.currentIndex);
          this.timeoutId = window.setTimeout(() => this.type(), this.deleteSpeed);
        } else {
          this.isDeleting = false;
          this.currentTextIndex = (this.currentTextIndex + 1) % this.texts.length;
          this.timeoutId = window.setTimeout(() => this.type(), this.speed);
        }
      } else {
        if (this.currentIndex < currentText.length) {
          this.currentIndex++;
          this.element.textContent = currentText.substring(0, this.currentIndex);
          this.timeoutId = window.setTimeout(() => this.type(), this.speed);
        } else {
          if (this.texts.length > 1) {
            this.isDeleting = true;
            this.timeoutId = window.setTimeout(() => this.type(), this.pauseTime);
          }
        }
      }
    }

    destroy() {
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
    }
  }

  // --- ライフサイクル管理（重複初期化・残存タイマー対策） ---
  const GLOBAL_FLAG = '__twBound';
  const ELEM_PROP = '__tw'; // 各要素にインスタンスをぶら下げる
  const DATA_FLAG = 'twInited'; // data-tw-inited

  function initTypewriters(root = document) {
    root.querySelectorAll('.typewriter').forEach((el) => {
      const elem = /** @type {HTMLElement} */(el);
      if (elem.dataset[DATA_FLAG] === '1' && elem[ELEM_PROP]) return; // 二重初期化防止
      const inst = new TypewriterEffect(elem);
      elem[ELEM_PROP] = inst;
      elem.dataset[DATA_FLAG] = '1';
    });
  }

  function destroyTypewriters(root = document) {
    root.querySelectorAll('.typewriter').forEach((el) => {
      const elem = /** @type {HTMLElement} */(el);
      elem[ELEM_PROP]?.destroy?.();
      delete elem[ELEM_PROP];
      delete elem.dataset[DATA_FLAG];
    });
  }

  // 初期表示
  initTypewriters();

  // Swupがいる場合のみ、willReplaceで破棄 → contentReplacedで再初期化
  if (!window[GLOBAL_FLAG]) {
    document.addEventListener('swup:willReplace', () => {
      destroyTypewriters(document);
    }, { passive: true });

    document.addEventListener('swup:contentReplaced', () => {
      initTypewriters(document);
    }, { passive: true });

    window[GLOBAL_FLAG] = true;
  }
</script>

<style>
  .typewriter { position: relative; }
  .typewriter::after {
    content: "|";
    animation: blink 1s infinite;
    margin-left: 2px;
  }
  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }
</style>
